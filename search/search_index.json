{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Data Structure Notes","text":""},{"location":"lists/linked-list/","title":"Linked List","text":"<p>A linked list is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next.</p> <p>The purpose of a linked list is to provide a consistent mechanism to store and access an arbitrary amount of data.</p> <p>It is a data structure consisting of a collection of nodes which together represent a sequence. In its most basic form, each node contains: data, and a reference (in other words, a link) to the next node in the sequence.</p> <p>This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. More complex variants add additional links, allowing more efficient insertion or removal of nodes at arbitrary positions.</p> <p>A drawback of linked lists is that access time is linear (and difficult to pipeline). Faster access, such as random access, is not feasible.</p> <p>They can be used to implement several other common abstract data types, including lists, stacks, queues and associative arrays (dictionaries).</p>"},{"location":"lists/linked-list/#linked-list-types","title":"Linked List Types","text":""},{"location":"lists/linked-list/#singly-linked-list","title":"Singly linked list","text":"<p>Singly linked lists contain nodes which have a data field as well as 'next' field, which points to the next node in line of nodes. Operations that can be performed on singly linked lists include insertion, deletion and traversal.</p> <p></p>"},{"location":"lists/linked-list/#doubly-linked-list","title":"Doubly linked list","text":"<p>In a doubly linked list, each node contains, besides the next-node link, a second link field pointing to the 'previous' node in the sequence. The two links may be called 'forwards' and 'backwards', or 'next' and 'prev'.</p> <p></p> <p>A technique known as XOR-linking allows a doubly linked list to be implemented using a single link field in each node. However, this technique requires the ability to do bit operations on addresses, and therefore may not be available in some high-level languages.</p> <p>Many modern operating systems use doubly linked lists to maintain references to active processes, threads, and other dynamic objects. A common strategy for rootkits to evade detection is to unlink themselves from these lists.</p>"},{"location":"lists/linked-list/#multiply-linked-list","title":"Multiply linked list","text":"<p>In a multiply linked list, each node contains two or more link fields, each field being used to connect the same set of data records in a different order of same set (e.g., by name, by department, by date of birth, etc.).</p> <p>While doubly linked lists can be seen as special cases of multiply linked list, the fact that the two and more orders are opposite to each other leads to simpler and more efficient algorithms, so they are usually treated as a separate case.</p>"},{"location":"lists/linked-list/#circular-linked-list","title":"Circular linked list","text":"<p>In the last node of a list, the link field often contains a <code>null</code> reference, a special value is used to indicate the lack of further nodes.</p> <p>A less common convention is to make it point to the first node of the list; in that case, the list is said to be 'circular' or 'circularly linked'; otherwise, it is said to be 'open' or 'linear'.</p> <p></p> <p>In the case of a circular doubly linked list, the first node also points to the last node of the list.</p>"},{"location":"lists/linked-list/#tradeoffs","title":"Tradeoffs","text":"Operation Linked list Array Dynamic array Balanced tree Random access list Hashed array tree Indexing O(n) O(1) O(1) O(log n) O(log n) O(1) Insert/delete at start O(1) N/A O(n) O(log n) O(1) O(n) Insert/delete at end O(n) N/A O(1) amortized O(log n) O(log n) updating O(1) amortized Insert/delete in middle Search+O(1) N/A O(n) O(log n) O(log n) updating O(n) Wasted space (average) O(n) 0 O(n) O(n) O(n) O(\u221an) <p>A dynamic array is a data structure that allocates all elements contiguously in memory, and keeps a count of the current number of elements. If the space reserved for the dynamic array is exceeded, it is reallocated and (possibly) copied, which is an expensive operation.</p> <p>Linked lists have several advantages over dynamic arrays.</p> <p>Insertion or deletion of an element at a specific point of a list, assuming that we have indexed a pointer to the node (before the one to be removed, or before the insertion point) already, is a constant-time operation (otherwise without this reference it is O(n)), whereas insertion in a dynamic array at random locations will require moving half of the elements on average, and all the elements in the worst case. While one can \"delete\" an element from an array in constant time by somehow marking its slot as \"vacant\", this causes fragmentation that impedes the performance of iteration.</p> <p>On the other hand, dynamic arrays (as well as fixed-size arrays) allow constant-time random access, while linked lists allow only sequential access to elements. Singly linked lists, in fact, can be easily traversed in only one direction. This makes linked lists unsuitable for applications where it's useful to look up an element by its index quickly, such as heapsort. Sequential access on arrays and dynamic arrays is also faster than on linked lists on many machines, because they have optimal locality of reference and thus make good use of data caching.</p> <p>Another disadvantage of linked lists is the extra storage needed for references, which often makes them impractical for lists of small data items such as characters or boolean values, because the storage overhead for the links may exceed by a factor of two or more the size of the data. In contrast, a dynamic array requires only the space for the data itself (and a very small amount of control data). It can also be slow, and with a na\u00efve allocator, wasteful, to allocate memory separately for each new element, a problem generally solved using memory pools.</p> <p>A balanced tree has similar memory access patterns and space overhead to a linked list while permitting much more efficient indexing, taking O(log n) time instead of O(n) for a random access. However, insertion and deletion operations are more expensive due to the overhead of tree manipulations to maintain balance. Schemes exist for trees to automatically maintain themselves in a balanced state: AVL trees or red-black trees.</p>"},{"location":"lists/linked-list/#singly-linked-linear-lists-vs-other-lists","title":"Singly linked linear lists vs. other lists","text":"<p>While doubly linked and circular lists have advantages over singly linked linear lists, linear lists offer some advantages that make them preferable in some situations.</p> <p>A singly linked linear list is a recursive data structure, because it contains a pointer to a smaller object of the same type. For that reason, many operations on singly linked linear lists (such as merging two lists, or enumerating the elements in reverse order) often have very simple recursive algorithms, much simpler than any solution using iteration. While those recursive solutions can be adapted for doubly linked and circularly linked lists, the procedures generally need extra arguments and more complicated base cases.</p> <p>Linear singly linked lists also allow tail-sharing, the use of a common final portion of sub-list as the terminal portion of two different lists.</p>"},{"location":"lists/linked-list/#doubly-linked-vs-singly-linked","title":"Doubly linked vs. singly linked","text":"<p>Double-linked lists require more space per node (unless one uses XOR-linking), and their elementary operations are more expensive; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a doubly linked list, one can insert or delete a node in a constant number of operations given only that node's address. To do the same in a singly linked list, one must have the address of the pointer to that node, which is either the handle for the whole list (in case of the first node) or the link field in the previous node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as persistent data structures</p>"},{"location":"lists/linked-list/#circularly-linked-vs-linearly-linked","title":"Circularly linked vs. linearly linked","text":"<p>A circularly linked list may be a natural option to represent arrays that are naturally circular, e.g. the corners of a polygon, a pool of buffers that are used and released in FIFO (\"first in, first out\") order, or a set of processes that should be time-shared in round-robin order. In these applications, a pointer to any node serves as a handle to the whole list.</p> <p>With a circular list, a pointer to the last node gives easy access also to the first node, by following one link. Thus, in applications that require access to both ends of the list (e.g., in the implementation of a queue), a circular structure allows one to handle the structure by a single pointer, instead of two.</p> <p>The simplest representation for an empty circular list (when such a thing makes sense) is a null pointer, indicating that the list has no nodes. Without this choice, many algorithms have to test for this special case, and handle it separately. By contrast, the use of null to denote an empty linear list is more natural and often creates fewer special cases.</p>"},{"location":"lists/linked-list/#linked-list-operations","title":"Linked List operations","text":"Text Only<pre><code>struct Node&lt;T&gt;\n{\n  T data, // The data being stored in the node\n  Node next // A reference to the next node, null for last node\n}\n</code></pre> Text Only<pre><code>struct LinkedList\n{\n  Node head // points to first node of list; null for empty list\n}\n</code></pre> Text Only<pre><code>node\u00a0= list.first_node\nwhile (node != null)\n{\n  // do something with node.data\n  node\u00a0= node.next;\n}\n</code></pre>"},{"location":"lists/linked-list/#node-insertion","title":"Node Insertion","text":"Text Only<pre><code>// insert new_node after node\nfunc insert_after(Node node, Node new_node)\n{\n  new_node.next\u00a0= node.next;\n  node.next = new_node;\n}\n</code></pre> Text Only<pre><code>func insert_beginning(LinkedList list, Node&lt;T&gt; new_node)\n{\n  // insert node before current first node\n  new_node.next = list.first_node\n  list.first_node\u00a0= new_node\n}\n</code></pre>"},{"location":"lists/linked-list/#node-removal","title":"Node Removal","text":"Text Only<pre><code>// remove node past this one\nfunc remove_after(Node node)\n{\n  old_node\u00a0= node.next;\n  node.next\u00a0= node.next.next;\n  destroy old_node;\n}\n</code></pre> Text Only<pre><code>// remove first node\nfunc remove_beginning(LinkedList list)\n{\n  old_node\u00a0= list.first_node\n  list.first_node\u00a0= list.first_node.next // point past deleted node\n  destroy old_node\n}\n</code></pre>"}]}